---
phase: 03-core-grading-experience
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/api/app.py
  - src/api/websocket.py
  - src/core/session.py
autonomous: true
requirements:
  - GRAD-03
  - GRAD-04
  - GRAD-05
  - GRAD-06
user_setup: []

must_haves:
  truths:
    - "User can choose single or dual-LLM grading mode before grading starts"
    - "Grading runs in background with WebSocket progress updates"
    - "Progress events sent: copy_start, question_done, copy_done, copy_error, session_complete"
    - "Dual-LLM mode runs two models independently and stores comparison results"
    - "LLM reads handwritten content directly via Gemini Vision API (no OCR step)"
  artifacts:
    - path: "src/api/app.py"
      provides: "POST /grade endpoint with mode selection"
      exports: ["start_grading"]
    - path: "src/api/websocket.py"
      provides: "ConnectionManager for progress broadcasting"
      contains: "class ConnectionManager, create_progress_callback"
    - path: "src/core/session.py"
      provides: "GradingSessionOrchestrator.grade_all() with progress callback"
      contains: "async def grade_all(progress_callback)"
  key_links:
    - from: "src/api/app.py"
      to: "src/core/session.py"
      via: "GradingSessionOrchestrator instantiation"
      pattern: "GradingSessionOrchestrator(session_id=session_id, user_id=user_id)"
    - from: "src/api/app.py"
      to: "src/api/websocket.py"
      via: "WebSocket progress callback"
      pattern: "ws_manager.create_progress_callback"
    - from: "src/core/session.py"
      to: "src/api/websocket.py"
      via: "progress_callback function"
      pattern: "await progress_callback(event_type, data)"
---

<objective>
Implement LLM grading execution with real-time WebSocket progress updates and single/dual-LLM mode selection.

This plan enables the core grading workflow: user selects grading mode, grading runs in background task, progress events stream via WebSocket, and graded results persist with single or dual-LLM comparison data.

Purpose: Execute the AI grading process with user-visible progress tracking, leveraging existing GradingSessionOrchestrator and ConnectionManager infrastructure.

Output: Enhanced /grade endpoint with mode parameter, WebSocket progress event structure, background task execution.
</objective>

<execution_context>
@/home/olivier/.claude/get-shit-done/workflows/execute-plan.md
@/home/olivier/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-core-grading-experience/03-CONTEXT.md
@.planning/phases/03-core-grading-experience/03-RESEARCH.md
@.planning/phases/03-core-grading-experience/03-01-PLAN.md
@src/api/app.py
@src/api/websocket.py
@src/core/session.py

<interfaces>
<!-- From src/api/websocket.py - Existing progress infrastructure -->
```python
class ConnectionManager:
    async def broadcast_event(self, session_id: str, event_type: str, data: dict):
        """Broadcast a typed event to all connections."""

    def create_progress_callback(self, session_id: str):
        """Create async callback function for grading orchestrator."""
        # Returns: async def callback(event_type: str, data: dict)
```

<!-- From src/api/app.py - Existing grading endpoint (lines 754-856) -->
```python
@app.post("/api/sessions/{session_id}/grade", response_model=GradeResponse)
async def start_grading(session_id: str, background_tasks: BackgroundTasks, current_user = Depends(get_current_user)):
    # Creates orchestrator, gets PDF paths, starts background task
    # Uses ws_manager.create_progress_callback(session_id)
```

<!-- From src/core/session.py - Orchestrator grading flow -->
```python
class GradingSessionOrchestrator:
    def __init__(self, session_id: str, user_id: str, grading_mode: str = None, ...):
        # grading_mode: "individual", "batch", or "hybrid"
        # Supports force_single_llm parameter

    async def analyze_only(self):
        """Run analysis phase (extract content from PDFs)."""

    async def grade_all(self, progress_callback: callable = None):
        """Grade all copies with optional progress callback."""
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add grading mode selection to grade endpoint</name>
  <files>src/api/schemas.py, src/api/app.py</files>
  <action>
First, add schema to src/api/schemas.py:

```python
class StartGradingRequest(BaseModel):
    grading_mode: Literal["single", "dual"] = "dual"
    """Single LLM for faster grading, dual LLM for verification"""
```

Then update POST /api/sessions/{session_id}/grade in src/api/app.py:

1. Accept StartGradingRequest body parameter (add after session_id)
2. Pass grading_mode to GradingSessionOrchestrator:
   - If request.grading_mode == "single": set `force_single_llm=True`
   - If request.grading_mode == "dual": use default (comparison mode from settings)
3. Store selected mode in session_progress[session_id]["grading_mode"] for UI reference
4. Return GradeResponse with selected mode included

The orchestrator already supports force_single_llm parameter - wire it through the endpoint.
</action>
  <verify>
grep -n "StartGradingRequest\|grading_mode\|force_single_llm" src/api/app.py | head -10
</verify>
  <done>
Grade endpoint accepts single/dual mode selection and passes to orchestrator via force_single_llm parameter.
</done>
</task>

<task type="auto">
  <name>Task 2: Define WebSocket progress event structure</name>
  <files>src/api/app.py</files>
  <action>
Define and document the progress event types that GradingSessionOrchestrator should send via progress_callback.

Add constants after imports in src/api/app.py:

```python
# WebSocket Progress Event Types
PROGRESS_EVENT_COPY_START = "copy_start"
PROGRESS_EVENT_QUESTION_DONE = "question_done"
PROGRESS_EVENT_COPY_DONE = "copy_done"
PROGRESS_EVENT_COPY_ERROR = "copy_error"
PROGRESS_EVENT_SESSION_COMPLETE = "session_complete"
PROGRESS_EVENT_SESSION_ERROR = "session_error"
```

Update the background task in start_grading() to send these events with proper data structure:

```python
# Example events (implement in grade_task background function):
await ws_manager.broadcast_event(session_id, PROGRESS_EVENT_COPY_START, {
    "copy_index": i,
    "total_copies": total,
    "student_name": copy.student_name or "Copie #{i+1}",
    "stage": "reading"  # or "grading"
})

await ws_manager.broadcast_event(session_id, PROGRESS_EVENT_QUESTION_DONE, {
    "copy_index": i,
    "question_id": qid,
    "grade": grade,
    "max_points": max_pts,
    "agreement": True  # for dual mode
})

await ws_manager.broadcast_event(session_id, PROGRESS_EVENT_COPY_DONE, {
    "copy_index": i,
    "student_name": copy.student_name or "Copie #{i+1}",
    "total_score": total,
    "max_score": max_score,
    "confidence": 0.85
})
```

The orchestrator already calls progress_callback - ensure it sends these event types with correct data structure.
</action>
  <verify>
grep -n "PROGRESS_EVENT\|broadcast_event.*PROGRESS_EVENT" src/api/app.py | head -15
</verify>
  <done>
Progress events follow defined structure: copy_start, question_done, copy_done, copy_error, session_complete with consistent data fields.
</done>
</task>

<task type="auto">
  <name>Task 3: Add progress sync for WebSocket reconnection</name>
  <files>src/api/app.py</files>
  <action>
Update the /api/sessions/{session_id}/ws WebSocket endpoint to send current progress state on connection.

Modify the websocket_progress function (around line 320-343):

```python
@app.websocket("/api/sessions/{session_id}/ws")
async def websocket_progress(websocket: WebSocket, session_id: str):
    """WebSocket for real-time grading progress with reconnection support."""
    await ws_manager.connect(websocket, session_id)
    try:
        # Send current progress state on connect (for reconnection)
        if session_id in session_progress:
            progress = session_progress[session_id]
            await websocket.send_json({
                "type": "progress_sync",
                "data": {
                    "status": progress.get("status"),
                    "copies_uploaded": progress.get("copies_uploaded", 0),
                    "copies_graded": progress.get("copies_graded", 0),
                    "grading_mode": progress.get("grading_mode", "dual")
                }
            })

        # Keep connection alive
        while True:
            data = await websocket.receive_text()
            if data == "ping":
                await websocket.send_text("pong")
            # Handle client requests for current state
            elif data == "sync":
                if session_id in session_progress:
                    await websocket.send_json({
                        "type": "progress_sync",
                        "data": session_progress[session_id]
                    })
    except WebSocketDisconnect:
        ws_manager.disconnect(websocket, session_id)
```

This ensures clients that disconnect and reconnect receive the current state immediately.
</action>
  <verify>
grep -n "progress_sync\|sync.*session_progress" src/api/app.py | head -10
</verify>
  <done>
WebSocket sends progress_sync event on connect with current session state, enabling seamless reconnection.
</done>
</task>

</tasks>

<verification>
1. Start API: `uvicorn src.api.app:app --reload`
2. Create session, upload PDF, confirm pre-analysis
3. Connect WebSocket: `wscat -c ws://localhost:8000/api/sessions/{id}/ws`
4. Start grading with dual mode: `curl -X POST http://localhost:8000/api/sessions/{id}/grade -d '{"grading_mode": "dual"}' -H "Authorization: Bearer $TOKEN"`
5. Observe progress events: copy_start → question_done → copy_done → session_complete
6. Disconnect and reconnect WebSocket - verify progress_sync sent on connect
7. Start grading with single mode: verify force_single_llm is used
</verification>

<success_criteria>
1. POST /grade accepts grading_mode parameter ("single" or "dual")
2. Single mode uses force_single_llm, dual mode uses comparison mode
3. WebSocket sends 5 event types with consistent data structure
4. Reconnecting WebSocket receives progress_sync immediately
5. Grading runs in background task without blocking response
6. Errors during grading send copy_error events and continue with remaining copies
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-grading-experience/03-02-SUMMARY.md` with:
- Grading mode selection implementation
- WebSocket event structure documentation
- Reconnection handling behavior
</output>
